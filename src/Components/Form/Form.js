import React, {useState} from 'react'
import Input from '../Input/Input'
import Story from '../Story/Story'


export default function Forms() {
    //Providing the state with a mock object for initial values. This can be swapped out for any json package. In this project, we're dealing with parts of speech to render a story. In the english language, there are eight total parts to speech. With this in mind, not all are useful for a madlibs story, therefore we're only going to use five for now.
    //For this example, we will start with only 3 parts of speech, giving us three unique inputs, to demonstrate what would happen if new object pairs were to be added to state.

    let mockData = {
        noun: {
            noun1:
            {
                name:"noun1",
                value:""
            },
        },
        verb: {
            verb1: {
                name:"verb1",
                value:""
            }
        },
        adj: {
            adj1:{
                name:"adj1",
                value:""
            }
        }
    }
    // SpeechInputs holds a object of various parts of speech. Each category holds a unique child key with its own properties that will be used to populate the form inputs dynamically based upon the number of child keys currently available.
    const [speechInputs, setSpeechInputs] = useState(mockData)
    // Seperate storyComplete state. To keep our speechInputs dynamic as possible, perhaps in the event we wanted to swap a different state or package into speechInputs-  I wanted to keep storyComplete outside of it.
    const [storyComplete, setStoryComplete] = useState(false)
    // Upon selecting a dropdown box, addDropDown listens to the event and takes the value to be used.
    const addDropDown = (event) => {
        // Destructuring our event into target, then further destructuring our target into an easily accessible key for dynamic identification later on.
        const {target: {value} } = event
        // Toggle for a conditional later that will decide if the new input has a parent key in state or not.
        let isUniqueParent = null
        // uniqueName will be utilized to store a keyName generated by our conditional.
        let uniqueName = null
        // Creates an array of parent key names so we can work with an array instead.
        let parentKeys = Object.keys(speechInputs)
        // Check to see if the new input already has an existing key it can be nested into.
        if(parentKeys.includes(event.target.value)) {
            // Switch isUniqueParent to false if the condition above is true.
            isUniqueParent = false
            // Set uniqueName for child key name
            uniqueName = `${event.target.value}${Object.keys(speechInputs.[value]).length + 1}`
        } else {
            // If our input value is not found in the top level of our state object this will toggle our isUniqueParent to true and allow us to move onto our next conditionals for setting state.
            isUniqueParent = true
            // Set uniqueName to our target value, since it will be used as a parent key.
            uniqueName = event.target.value
        }
        // Check to see if uniqueParent got tripped to true before deciding how to set our state.
        // Note: could use a ternary here to clean it up some more.
        if(isUniqueParent) {
            // Create a new key name for the child object.
            let childKey = uniqueName + 1
            // Copy old state data and merge new object in when setting state.
            setSpeechInputs({...speechInputs, [uniqueName]:{[childKey]:{name:childKey, value:""}}})
        } else {
            // Copy old state and then access the key name we're adding a new child to, copy the old set of child keys and values and then add in the new child along with all of the original keys and values.
            setSpeechInputs({...speechInputs, [value]:{...speechInputs.[value], [uniqueName]:{name:uniqueName, value:""}}})
        }
    }
    // handleChange receives the event from the input components and accesses the props, then updates the state based upon what the user types into the box.
    const handleChange = (event) => {
        // Destructuring out name, id and value to have easier access to them as dynamic ids.
        const {target:{name, id, value} } = event
        //C opies the original state, then accesses the parent key. Then it accesses the nested childs key, and copies it's objects. Finally, it updates the child keys value properties and updates it with everything.
        setSpeechInputs({...speechInputs, [id]:{...speechInputs.[id], [name]:{value:[value]}}})
    }
   const handleSubmit = (event) => {
       // Keep the window from refreshing.
       event.preventDefault();
       // Set our story to complete so it may render.
       setStoryComplete(true)
   };
   const clearState = () => {
    // Resets our state back to the original mockData object.
    setSpeechInputs(mockData)
   }


///------------------------------------------------ All commented code left here to show different attempts and ideas to dynamically populated props and components.
////////// FIRST TRY
//    const getPartsOfSpeech = () => {
//        //An array of ALL parent keys
//         let parentKeys = Object.keys(speechInputs)
//         // console.log("Parent keys array:", parentKeys)-
//         // An array of ALL child keys
//         let childKeys = parentKeys.map(pKeys => {return Object.keys(speechInputs.[pKeys])})
//         // console.log("Child keys array:", childKeys)
//         //get an array of only paths for each childKeys value.
//         // let pathArray = []
//         // let pKeyMap = parentKeys.map(parentKeys => {
//         //     return `speechInputs.${parentKeys}.`
//         // })
//         // console.log("keyMap",pKeyMap)
//         // let cKeyMap = childKeys.map((value, index) => {
//         //     return value[index]
//         // })
//         // let childValues = parentKeys.map(pKeys => {return Object.keys(speechInputs.[pKeys]).map(cKeys => {return Object.values(speechInputs.[pKeys].[cKeys])})})
//         // console.log("Child values array:", childValues)
//         // let pathArray = []
//         // for(let i = 0; i < parentKeys.length; i++) {
//         //
//         //     let storePKey = parentKeys[i]
//         //
//         //     let storeCKey = ""
//         //     let storePath = ""
//         //     for(let j = 0; j < childKeys.length; j++) {
//         //
//         //         let secondLoopStoreCKey = childKeys[j]
//         //         storeCKey = secondLoopStoreCKey
//         //
//         //     }
//         //
//         //     storePath = `speechInputs.${storePKey}.${storeCKey}.value`
//         //
//         //     return pathArray.push(storePath)
//         // }
//         // An array of child values
//         // let childValues = childKeys.map(({...parentKeys},cKeys) => {return Object.values(speechInputs.[parentKeys].[cKeys])})
//         // let allEntries = Object.entries(speechInputs)
//         // let valuesOfEntriesOne = allEntries.map(childKey => {return childKey.map(value => value)})
//         // let testAccess = null
//         // let countParentKey = parentKeys.length
//         //An array of child keys
//         // let childKey = Object.keys(speechInputs.[parentkey])
//         //An array of child values
//         // let childValue = Object.value(speechInputs.[parentKey].[childKey])
//         // console.log(<Story {...childKeys} />)
//         // return (
//         //     <Story {...childValues.map((value, index) => {return value})} />
//         // )
//    }

//// SECOND ATTEMPT- This one works well, pulls all paths out of the parent and ALSO allows us to render the child componenet, however time was running out.

//Recursive function allows us to map through the object and return back all of the state objects paths.
//    const objectToPaths = (data) => {
//     let validId = /^[a-z_$][a-z0-9_$]*$/i;
//     let result = [];
//     findPath(data, "");
//     let valuesInArray = result.map(value => {return value.split('.').slice(1).reduce((o,i)=>o[i], speechInputs)})
//     console.log("result array", <Story {...valuesInArray}/>)
//     return (<Story {...valuesInArray}/>);

//     function findPath(data, s) {
//       if (data && typeof data === "object") {
//         if (Array.isArray(data)) {
//           for (let i = 0; i < data.length; i++) {
//             findPath(data[i], s + "[" + i + "]");
//           }
//         } else {
//           for (let p in data) {
//             if (validId.test(p)) {
//               findPath(data[p], s + "." + p);
//             } else {
//               findPath(data[p], s + "[\"" + p + "\"]");
//             }
//           }
//         }
//       } else {
//         result.push(s);
//       }
//     }
//         function convertString(string) {
//             string.split('.').slice(1).reduce((o,i)=>o[i], speechInputs)
//             // return string.split().reduce((o,i) => o[i], speechInputs)
//             // arr.map(value => {
//             //     return value.reduce((o,i)=>o[i], obj)
//             // })

//         }
//     }
////////----------------------------------

  return (
    <>
      <form onSubmit={handleSubmit}>
          {/* This can be easily modified to be more dynamic, such as a text box that sends the values of whats typed up to the state to define custom keys. The logic is already in place to handle what ever input you decide to have here, its really just looking at what the value is.  A simple drop down works well for right now to fit within the MadLibs project idea. Only Noun, Verb and Adj currently exist ahead of time in the mock data state, when a new option is selected from dropdown it will add a whole new nested object into state.*/}
          Use the dropdown to add new input fields. Note: please select a unique option each click.
          <br />
          {/* Minor bug- the dropdown options doesnt recognize a selection that the cursor is already on. Need to explore why that is. */}
        <select onChange={addDropDown}>
            <option default> Select a part of speech to add a new input.</option>
            <option value="noun">Noun</option>
            <option value="verb">Verb</option>
            <option value="adj">Adjective</option>
            <option value="adverb">Adverb</option>
            <option value="interj">Interjection</option>
        </select>
    <hr/>
        {
            // Acces our state object at top level and store the parent keys temporarily into an array so we can access the names and talk to the children keys.
            Object.keys(speechInputs).map((parentKey) => {
                // After mapping through the new array to capture the parent keys, we access the nested layer using the same pattern
                return Object.keys(speechInputs.[parentKey]).map(childKey => {
                    // Now that we have our child keys, we're abe to have our map render a component on return with the key names passed as props, along with our handleChange function and read access to its state values.
                    return <Input
                            parentKey={parentKey}
                            name={childKey}
                            value={speechInputs.[parentKey].[childKey].value}
                            handleChange={handleChange}
                            />
                })
            })
        }
        <br/>
        {/* Addtional feature idea: Remove input button */}
        <button onClick={handleSubmit}> Submit </button>
        <button onClick={clearState}>Clear</button>
      </form>
      <hr />
      {/* Conditional rendering to render our story only if the storyComplete state has been changed to true. */}
      { storyComplete === true ?
      // Passing our state down to the child to be used in building out the stories.
      <Story allState={speechInputs} /> : "Select your input fields you'd like above, fill them out, and then press submit to see what you've made!"}
    </>
  );
}
