import React, {useState} from 'react'
import Input from '../Input/Input'
import Story from '../Story/Story'


export default function Forms() {

    // TODO: Add remove input button. 

    //Providing the state with a mock object for initial values. This can be swapped out for any json package. In this project, we're dealing with parts of speech to render a story. In the english language, there are eight total parts to speech. With this in mind, not all are useful for a madlibs story, therefore we're only going to use five for now. 
    //For this example, we will start with only 3 parts of speech, giving us three unique inputs, to demonstrate what would happen if new object pairs were to be added to state. 

    let mockData = {
        noun: { 
            noun1:
            {
                name:"noun1",
                value:""
            },
        },
        verb: {
            verb1: {
                name:"verb1",
                value:""
            }
        },
        adj: {
            adj1:{
                name:"adj1",
                value:""
            }
        }
    }

    // speechInputs holds a object of various parts of speech. Each category holds a unique child key with its own properties that will be used to populate the form inputs dynamically based upon the number of child keys currently available.
    //Starts with a single child key nested inside each available parent key. 
    const [speechInputs, setSpeechInputs] = useState(mockData)
    // Seperate storyComplete state. To keep our speechInputs dynamic as possible, perhaps in the event we wanted to swap a different state or package into speechInputs-  I wanted to keep storyComplete outside of it. 
    const [storyComplete, setStoryComplete] = useState(false)

    // Upon selecting a dropdown box, addDropDown listens to the event and takes the value to be used.  
    const addDropDown = (event) => {

        // Destructuring our event into target, then further destructuring our target into an easily accessible key for dynamic identification later on.
        const {target: {value} } = event
        
        // Toggle for a conditional later that will decide if the new input has a parent key in state or not.
        let isUniqueParent = null
        // uniqueName will be utilized to store a keyName generated by our conditional.
        let uniqueName = null

        // Creates an array of parent key names so we can work with an array instead. 
        let parentKeys = Object.keys(speechInputs)

        // Check to see if the new input already has an existing key it can be nested into.
        if(parentKeys.includes(event.target.value)) {
            // Switch isUniqueParent to false if the condition above is true.
            isUniqueParent = false
            // Set uniqueName for child key name
            uniqueName = `${event.target.value}${Object.keys(speechInputs.[value]).length + 1}`
        } else {
            // If our input value is not found in the top level of our state object this will toggle our isUniqueParent to true and allow us to move onto our next conditionals for setting state. 
            isUniqueParent = true
            // Set uniqueName to our target value, since it will be used as a parent key.
            uniqueName = event.target.value
        }

        //Check to see if uniqueParent got tripped to true before deciding how to set our state.
        if(isUniqueParent === true) {
            //Create a new key name for the child object.
            let childKey = uniqueName + 1
            // Copy old state data and merge new object in when setting state.
            setSpeechInputs({...speechInputs, [uniqueName]:{[childKey]:{name:childKey, value:""}}})
        } else {
            // Copy old state and then access the key name we're adding a new child to, copy the old set of child keys and values and then add in the new child along with all of the original keys and values.
            setSpeechInputs({...speechInputs, [value]:{...speechInputs.[value], [uniqueName]:{name:uniqueName, value:""}}})
        }
        
    }

    //handleChange receives the event from the input components and accesses the props, then updates the state based upon what the user types into the box.
    const handleChange = (event) => {
        //Destructuring out name, id and value to have easier access to them as dynamic ids. 
        const {target:{name, id, value} } = event
        
        //Copies the original state, then accesses the parent key. Then it accesses the nested childs key, and copies it's objects. Finally, it updates the child keys value properties and updates it with everything.
        setSpeechInputs({...speechInputs, [id]:{...speechInputs.[id], [name]:{value:[value]}}})
    }
    

    // Our form submit function. Utilizes preventDefault to keep the page from refreshing on submission.
   const handleSubmit = (event) => {
       event.preventDefault();
       // Set our story to complete so it may render. 
       setStoryComplete(true)
   };

   const clearState = () => {
    //Quick alert to let the user know madlibs has reset.
    alert("Madlibs RESET!")
    //Resets our state back to the original mockData object.
    setSpeechInputs(mockData)
   }
        
   //push every path into an array
    


   const objectToPaths = (data) => {
    var validId = /^[a-z_$][a-z0-9_$]*$/i;
    var result = [];
    doIt(data, "");
    return result;
  
    function doIt(data, s) {
      if (data && typeof data === "object") {
        if (Array.isArray(data)) {
          for (var i = 0; i < data.length; i++) {
            doIt(data[i], s + "[" + i + "]");
          }
        } else {
          for (var p in data) {
            if (validId.test(p)) {
              doIt(data[p], s + "." + p);
            } else {
              doIt(data[p], s + "[\"" + p + "\"]");
            }
          }
        }
      } else {
        result.push(s);
      }
    }
  }


   const getPartsOfSpeech = () => {

       //An array of ALL parent keys
        let parentKeys = Object.keys(speechInputs)
        // console.log("Parent keys array:", parentKeys)-

        // An array of ALL child keys
        let childKeys = parentKeys.map(pKeys => {return Object.keys(speechInputs.[pKeys])})
        // console.log("Child keys array:", childKeys)


        

        //get an array of only paths for each childKeys value.

        // let pathArray = []

        // let pKeyMap = parentKeys.map(parentKeys => {
        //     return `speechInputs.${parentKeys}.`
        // })
        // console.log("keyMap",pKeyMap)

        // let cKeyMap = childKeys.map((value, index) => {
        //     return value[index]
        // })

        // let childValues = parentKeys.map(pKeys => {return Object.keys(speechInputs.[pKeys]).map(cKeys => {return Object.values(speechInputs.[pKeys].[cKeys])})})

        // console.log("Child values array:", childValues)


        //DUMB FOR LOOPS
        // let pathArray = []
        // for(let i = 0; i < parentKeys.length; i++) {
        //     console.log("ONE LEVEL DEEP")
        //     let storePKey = parentKeys[i]
        //     console.log("storePKey", storePKey)
        //     let storeCKey = ""
        //     let storePath = ""
        //     for(let j = 0; j < childKeys.length; j++) {
        //         console.log("SECOND LEVEL DEEP")
        //         let secondLoopStoreCKey = childKeys[j]
        //         storeCKey = secondLoopStoreCKey
        //         console.log("storeCKey", storeCKey)
        //     }
            
        //     console.log("IMMA ABOUT TO RETUUURRRNN")
        //     storePath = `speechInputs.${storePKey}.${storeCKey}.value`
        //     console.log("in the loop patharray", storePath)
        //     return pathArray.push(storePath)
        // }
        

        // An array of child values
        // let childValues = childKeys.map(({...parentKeys},cKeys) => {return Object.values(speechInputs.[parentKeys].[cKeys])})

        // let allEntries = Object.entries(speechInputs)

        //JUST A TON OF NESTED ARRAYS AND OBJECTS.
        // let valuesOfEntriesOne = allEntries.map(childKey => {return childKey.map(value => value)})
        // let testAccess = null
        



       

        //Number of parent keys
        let countParentKey = parentKeys.length
        //An array of child keys
        // let childKey = Object.keys(speechInputs.[parentkey])
        //An array of child values
        // let childValue = Object.value(speechInputs.[parentKey].[childKey])
        // console.log(<Story {...childKeys} />)
        // return (
        //     <Story {...childValues.map((value, index) => {return value})} />
        // )
   }

  return (
    <>
      <form onSubmit={handleSubmit}>
          {/* This can be easily modified to be more dynamic, such as a text box that sends the values of whats typed up to the state to define custom keys. The logic is already in place to handle what ever input you decide to have here, its really just looking at what the value is.  A simple drop down works well for right now to fit within the MadLibs project idea. Only Noun, Verb and Adj currently exist ahead of time in the mock data state, when a new option is selected from dropdown it will add a whole new nested object into state.*/}
        <select onChange={addDropDown}>
            <option default> Select a part of speech to add.</option>
            <option value="noun">Noun</option>
            <option value="verb">Verb</option>
            <option value="adj">Adjective</option>
            <option value="adverb">Adverb</option>
            <option value="interj">Interjection</option>
        </select>
    <hr/>
        {
            //Acces our state object at top level and store the parent keys temporarily into an array so we can access the names and talk to the children keys. 
            Object.keys(speechInputs).map((parentKey) => {
                //After mapping through the new array to capture the parent keys, we access the nested layer using the same pattern
                return Object.keys(speechInputs.[parentKey]).map(childKey => {
                    //Now that we have our child keys, we're abe to have our map render a component on return with the key names passed as props, along with our handleChange function and read access to its state values.
                    return <Input 
                            parentKey={parentKey}
                            name={childKey}
                            value={speechInputs.[parentKey].[childKey].value}
                            handleChange={handleChange}
                            />
                })
            })
        }
        <br/>
        <button onClick={handleSubmit}> Submit </button>
        <button onClick={clearState}>Clear</button>
      </form>

      <hr />
      
      { storyComplete === true ? 
      objectToPaths(speechInputs) : "Please fill out the input fields above, and press submit to see the story!"}
      
    </>
  );
}
